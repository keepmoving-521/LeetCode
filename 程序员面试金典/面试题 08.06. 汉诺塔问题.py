"""
在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。
一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。
移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。

你需要原地修改栈。

示例1:

 输入：A = [2, 1, 0], B = [], C = []
 输出：C = [2, 1, 0]
示例2:

 输入：A = [1, 0], B = [], C = []
 输出：C = [1, 0]
"""
class Solution(object):
    def hanota(self, A, B, C):
        """
        :type A: List[int]
        :type B: List[int]
        :type C: List[int]
        :rtype: None Do not return anything, modify C in-place instead.
        """
        def hanoi(n,x,y,z):
            if n == 1:
                z.append(x.pop())
                return
            else:
                hanoi(n-1,x,z,y)
                hanoi(1,x,y,z)
                hanoi(n-1,y,x,z)
        return hanoi(len(A),A,B,C)


"""
解题思路
递归设计的思路：参数，返回值，终止条件，递归条件及其主体。

由于原函数没有A柱的盘数，这题我们需要以A的盘数来决定递归是否进行，
如何进行，所以需要自己定义一个带A盘数的汉诺塔函数。
注意：hanoi(n,x,y,z)代表将x柱上的n个盘，借助y柱移动到z柱上。

返回值只需要空就行，这题只是把A的盘全部转移到C盘上，
所以Python使用一行代码C[:]=A[:]都能过。

当A只有一个盘的时候，我们需要将A的最后一个盘取出，放到C上，即C.append(A.pop())，
此时A盘空，返回即可，这里也是我们的递归终止条件。

然后当A不是一个盘的时候（可以是n!=1即else，也可以是n!=0，其实是一样的），
就需要进行递归主体的设计了。

我们将A柱除最下面的盘外的所有盘视为一个整体：
hanoi(n-1,x,z,y)首先将x柱上的n-1个盘，借助z柱移动到y柱上，
hanoi(1,x,y,z)再将x柱上的1个盘，借助y柱移动到z柱上（这里其实没有用到y柱），
hanoi(n-1,y,x,z)最后将y柱上的n-1个盘，借助x柱移动到z柱上。

移动完成！
"""